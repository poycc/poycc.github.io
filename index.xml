<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>enddi</title>
    <link>/</link>
    <description>Recent content on enddi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 29 Dec 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>机器学习笔记-1（定义、监督学习、无监督学习）</title>
      <link>/post/machine-learning/machine-learning-1/</link>
      <pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/machine-learning/machine-learning-1/</guid>
      <description>
        


&lt;div id=&#34;what-is-machine-learning&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What is machine learning？&lt;/h1&gt;
&lt;div id=&#34;arthur-samuel1959&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Arthur Samuel（1959）的定义&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Machine Learning : Field of study that give computers the ability to learn without being explicitly programmed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;在进行特定编程情况下给予计算机学习能力的领域&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Samuel的定义可以回溯到50年代，他编写了一个西洋棋程序。 这程序神奇之处在于，编程者自己并不是个下棋高手。但因为他太菜了，于是就通过编程，让西洋棋程序自己跟自己下了上万盘棋。通过观察哪种布局（棋盘位置）会赢，哪种布局会输，久而久之，这西洋棋程序明白了什么是好的布局， 什么样是坏的布局。然后就牛逼大发了，程序通过学习后， 玩西洋棋的水平超过了Samuel。这绝对是令人注目的成果。尽管编写者自己是个菜鸟，但因为 计算机有着足够的耐心，去下上万盘的棋， 没有人有这耐心去下这么多盘棋。通过这些练习，计算机获得无比丰富的经验，于是渐渐成为了 比Samuel更厉害的西洋棋手。&lt;/p&gt;
&lt;p&gt;上述这个是有点不正式的定义， 也比较古老。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;tom-mitchell1998&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;卡内基梅隆大学Tom Mitchell（1998）的定义&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P,improves with experience E.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个程序被认为能从经验E中学习，解决任务T，达到 性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。&lt;/p&gt;
&lt;p&gt;Example: playing checkers.&lt;/p&gt;
&lt;p&gt;E = the experience of playing many games of checkers&lt;/p&gt;
&lt;p&gt;T = the task of playing checkers.&lt;/p&gt;
&lt;p&gt;P = the probability that the program will win the next game.&lt;/p&gt;
&lt;p&gt;Machine learning algorithms：&lt;/p&gt;
&lt;p&gt;目前主要两种学习算法类型为：监督学习（Supervised learning）和无监督学习（Unsupervised learning）。&lt;/p&gt;
&lt;p&gt;此外，大家也许在后面的学习听到诸如强化学习 （Reinforcement learning）和推荐系统（Recommender systems）等名词。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;supervised-learning&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;监督学习（Supervised learning）&lt;/h1&gt;
&lt;p&gt;假如你想预测一下现在的房价，这是一个数据集，横轴是房子的大小，纵轴是房价。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;根据给定数据，假设你朋友有栋房子，750平尺（70平米） 想知道这房子能卖多少，好卖掉。&lt;/p&gt;
&lt;p&gt;那么，学习算法怎么帮你呢？学习算法可以： 绘出一条直线，让直线尽可能匹配到所有数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;基于此，看上去，那个房子应该、可能、也许、大概 卖到15万美元（一平米两千刀！）。&lt;/p&gt;
&lt;p&gt;但这不是唯一的学习算法。 可能还有更好的。比如不用直线了， 可能平方函数会更好， 即二次多项式更符合数据集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/3.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监督学习，意指给出一个算法， 需要部分数据集已经有正确答案。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如给定房价数据集， 对于里面每个数据，算法都知道对应的正确房价， 即这房子实际卖出的价格。算法的结果就是算出更多的正确价格，比如那个新房子， 你朋友想卖的那个。&lt;/p&gt;
&lt;p&gt;用更术语的方式来定义，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监督学习又叫回归问题，（应该是回归属于监督中的一种） 意指要预测一个连续值的输出，比如房价。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然从技术上，一般把房价记到美分单位。 所以实际还是个离散值，但通常把它看作实际数字， 是一个标量值，一个连续值的数，而术语回归， 意味着要预测这类连续值属性的种类。&lt;/p&gt;
&lt;p&gt;另一个监督学习的例子，我和一些朋友之前研究的领域。让我们来看医学记录，并预测胸部肿瘤是恶性良性。&lt;/p&gt;
&lt;p&gt;如果某人发现有胸部肿瘤，恶性肿瘤有害又危险， 良性肿瘤则是少害。显然人们很关注这个。&lt;/p&gt;
&lt;p&gt;让我们看一个收集好的数据集， 假设在数据集中，横轴表示肿瘤的大小，纵轴我打算圈上0或1，是或否， 即肿瘤是恶性的还是良性的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/4.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这是一个胸部肿瘤的数据集，横轴表示肿瘤的大小，纵轴表示肿瘤是否为良性的。&lt;/p&gt;
&lt;p&gt;假如非常不幸，我们的胸部长了肿瘤，对应的机器学习算法就是，根据你的这个尺寸，估算出一个概率，即肿瘤为良性肿瘤的概率或者恶性肿瘤的概率。&lt;/p&gt;
&lt;p&gt;当然这也是一个分类（Classification）问题。分类就是要预测一个离散值的输出。&lt;/p&gt;
&lt;p&gt;这里是0/1，也就是良性/恶性。当然在分类问题当中，有时候会超过两个值的输出。&lt;/p&gt;
&lt;p&gt;举个具体例子， 胸部肿瘤可能有三种类型，所以要预测离散值0，1，2，3 0就是良性肿瘤，没有癌症。 1 表示1号癌症，假设总共有三种癌症。 2 是2号癌症，3 就是3号癌症。 这同样是个分类问题，因为它的输出的离散值集合分别对应于无癌，1号，2号，3号癌症&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/5.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在分类问题中，还有另一种作图方式 来描述数据。我画你猜。要用到些许不同的符号集合 来描绘数据。如果肿瘤大小作为唯一属性， 被用于预测恶性良性，可以把数据作图成这样。 使用不同的符号来表示良性和 恶性，即阴性和阳性。所以，不再统一画叉叉了， 改用圈圈来代表良性肿瘤，就像这样。 仍沿用X（叉叉）代表恶性肿瘤。希望你能明白。 我所做的就是，把在上面的数据， 映射下来。再用不同的符号， 圈和叉来分别代表良性和恶性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/6.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在上例中，只使用了一个特征属性，即肿瘤块大小，来预测肿瘤是恶性良性。在其它机器学习问题里， 有着不只一个的特征和属性。例子，现在不只是知道肿瘤大小，病人年龄和肿瘤大小都知道了。这种情况下数据集如表图所示，有些病人，年龄、肿瘤已知，不同的病人，会有一点不一样，肿瘤恶性，则用叉来代表。所以，假设 有一朋友得了肿瘤。肿瘤大小和年龄 落在此处。那么依据这个给定的数据集，学习算法 所做的就是画一条直线，分开恶性肿瘤和良性肿瘤，所以学习算法会 画条直线，像这样，把两类肿瘤分开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/7.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如果它在那边，学习算法就说你朋友的肿瘤在良性一边，因此更可能是良性的。&lt;/p&gt;
&lt;p&gt;在上面的示例中，我们都只是使用到很少的特征计算，当处理无限多特征条件时，而计算机性能有限，因此我们需要使用一种叫做支持向量机的算法，来让电脑能够处理无限多的特征。&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Supervised Learning：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Supervised learning problems are categorized into “regression” and “classification” problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div id=&#34;unsupervised-learning&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;无监督学习（Unsupervised Learning）&lt;/h1&gt;
&lt;p&gt;在上面的监督学习中，在其数据集里面，每一个样本都被标注为正样本或者负样本。对于每一个样本，我们也清楚知道什么才是正确的答案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/8.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在无监督学习中，我们没有属性或者标签这个概念了。也就是所有的数据都是一样的，没有什么区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/9.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以在无监督学习中我们只有一个数据集，没人告诉我们该怎么做，我们也不知道每个数据点究竟是什么意思，相反，它只告诉我们，现在有一个数据集，你能在其中找到某种结构吗？ 对于给定的数据集，无监督学习算法可能判定，该数据集包含两个不同的聚类，你看，这是第一个聚类，然后这是另一个聚类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/10.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;基于给出的数据集，无监督学习算法可以给出不同的聚类，这就是所谓的聚类算法。&lt;/p&gt;
&lt;p&gt;举个例子，例如看新闻的网页：news.google.com，其实原理和现在我们经常所提的聚合新闻一样，简单的说就是能够根据某一话题自行将同样关键词的新闻信息聚拢在一起，方便读者阅览。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/11.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;谷歌新闻每天去收集成千上万的网络新闻，然后将他们分组，组成一个个的新闻专题。当我们点进去一个新闻专题的时候，就会有全球各地的媒体对于该新闻的报导。&lt;/p&gt;
&lt;p&gt;下面是一个基因的例子。给定一组不同的个体，对于每一个不同的个体，检测它们是否拥有某个特定的基因，图中绿色、红色、黑色等就是展示了这些不同的个体是否拥有一个特定的基因的不同程度。然后我们运行一个聚类算法，把不同的个体归入不同的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/machine-learning/12.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;因为我们没有提前告诉我们的算法，这种基因类型是具体属于哪一类的人，我们只是告诉算法，这里有一堆数据，然后让其自动的按照得到的类型把这些个体进行分类。&lt;/p&gt;
&lt;p&gt;接下来还有讲到以下一些应用无监督学习或者聚类算法的例子：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;用来组织大型的计算机集群：找出趋向于协同工作的机器，如果将这些机器放在一起，将能够使数据中心更加高效的工作。&lt;/li&gt;
&lt;li&gt;用于社交网络的分析：使用算法对某种社交软件的好友进行分析，来区分出好友粘度。&lt;/li&gt;
&lt;li&gt;利用公司庞大的客户信息数据库，自动找出不同的市场分割，并自动将客户分到不同的细分市场中，以此来进行更有效的销售。&lt;/li&gt;
&lt;li&gt;进行天文数据分析。&lt;/li&gt;
&lt;li&gt;鸡尾酒宴问题：在实验对象不同距离的话筒前，说出不同的语言内容，然后利用计算机自动进行内容识别和分离。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unsupervised Learning&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Unsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We can derive this structure by clustering the data based on relationships among the variables in the data.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;With unsupervised learning there is no feedback based on the prediction results.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔记整理自Coursera吴恩达机器学习课程。&lt;/p&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>证明两条非垂直直线的斜率互为负倒数</title>
      <link>/post/math/2018-12-14-%E8%AF%81%E6%98%8E%E4%B8%A4%E6%9D%A1%E9%9D%9E%E5%9E%82%E7%9B%B4%E7%9B%B4%E7%BA%BF%E7%9A%84%E6%96%9C%E7%8E%87%E4%BA%92%E4%B8%BA%E8%B4%9F%E5%80%92%E6%95%B0/</link>
      <pubDate>Fri, 14 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/math/2018-12-14-%E8%AF%81%E6%98%8E%E4%B8%A4%E6%9D%A1%E9%9D%9E%E5%9E%82%E7%9B%B4%E7%9B%B4%E7%BA%BF%E7%9A%84%E6%96%9C%E7%8E%87%E4%BA%92%E4%B8%BA%E8%B4%9F%E5%80%92%E6%95%B0/</guid>
      <description>
        


&lt;div id=&#34;section&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;基础知识&lt;/h1&gt;
&lt;div id=&#34;section-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;相似三角形的判定定理：&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;strong&gt;AA&lt;/strong&gt;：如果一个三角形的两个角与另一个三角形的两个角对应相等，这两个三角形相似；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SAS&lt;/strong&gt;：如果两个三角形的两组对应边成比例，并且对应的夹角相等，这两个三角形相似；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSS&lt;/strong&gt;：如果两个三角形的三组对应边成比例，那么这两个三角形相似。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;section-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;增量&lt;/h2&gt;
&lt;p&gt;当平面上一个质点从一个点移动到另一个点，终点坐标减去起点坐标就可以求出坐标的增量。&lt;/p&gt;
&lt;p&gt;假如一个质点从点(&lt;span class=&#34;math inline&#34;&gt;\(x_1,y_1\)&lt;/span&gt;)移动到(&lt;span class=&#34;math inline&#34;&gt;\(x_2,y_2\)&lt;/span&gt;)，那么这个点的坐标增量为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \Delta x = x_2 - x_1 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \Delta y = y_2 - y_1 \]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;section-3&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;直线的斜率&lt;/h2&gt;
&lt;p&gt;每条不垂直的直线&lt;code&gt;$L$&lt;/code&gt;都有一个斜率，每行进单位距离时高度的变化就是这条直线的斜率，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/math/1.png&#34; style=&#34;width:50.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在上图中，&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\Delta x = x_2 - x_1\)&lt;/span&gt;，是从&lt;span class=&#34;math inline&#34;&gt;\(p_1\)&lt;/span&gt;到&lt;span class=&#34;math inline&#34;&gt;\(p_2\)&lt;/span&gt;的行进距离；&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\Delta y = y_2 - y_1\)&lt;/span&gt;，是从&lt;span class=&#34;math inline&#34;&gt;\(p_1\)&lt;/span&gt;到&lt;span class=&#34;math inline&#34;&gt;\(p_2\)&lt;/span&gt;的升高；&lt;/p&gt;
&lt;p&gt;那么直线&lt;span class=&#34;math inline&#34;&gt;\(L\)&lt;/span&gt;的斜率为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ m = \frac{升高}{行进距离} = \frac{\Delta y}{\Delta x} = \frac{y_2 - y_1}{x_2 - x_1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;增加时上升的直线的斜率为正数；&lt;/p&gt;
&lt;p&gt;当&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;增加时下降的直线的斜率为负数；&lt;/p&gt;
&lt;p&gt;水平线的直线的斜率为0；&lt;/p&gt;
&lt;p&gt;垂直的直线&lt;span class=&#34;math inline&#34;&gt;\(\Delta x = 0\)&lt;/span&gt;，此时斜率无意义。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;section-4&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;证明两条非垂直直线的斜率互为负倒数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/post/math/2.png&#34; style=&#34;width:80.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，证明步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\angle CAD +\angle ACD = 90^\circ\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\angle ACD+\angle BCD = 90^\circ\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此：&lt;span class=&#34;math inline&#34;&gt;\(\angle CAD = \angle BCD\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据相似三角形的判定定理，可以得出&lt;span class=&#34;math inline&#34;&gt;\(\Delta ADC\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(\Delta BCD\)&lt;/span&gt;相似，所以：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[m_1 = tan \phi_1 = \frac{a}{h}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[m_2 = tan \phi_2 = - \frac{h}{a}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[m_1m_2 = \left(\frac{a}{h}\right)\left(-\frac{h}{a}\right) = -1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以，两条非垂直直线的斜率互为负倒数。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>inline-block样式使用</title>
      <link>/post/css/inline-block-md/</link>
      <pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/css/inline-block-md/</guid>
      <description>
        

&lt;!-- @import &#34;[TOC]&#34; {cmd=&#34;toc&#34; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;p&gt;&lt;div id=&#34;top&#34;&gt;
&lt;!-- @import &#34;[TOC]&#34; {cmd=&#34;toc&#34; depthFrom=1 depthTo=6 orderedList=false} --&gt;&lt;/p&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#内容间隙问题&#34;&gt;内容间隙问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#不同高度的对齐问题&#34;&gt;不同高度的对齐问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /code_chunk_output --&gt;

&lt;p&gt;在页面布局的过程中，我们经常会使用&lt;code&gt;display: inline-block&lt;/code&gt;方法对目标内容的显示进行设置，在使用过程中发现以下几个特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;呈现inline特性（不占据一整行，宽度由内容宽度决定）&lt;/li&gt;
&lt;li&gt;呈现block特性（可以设置宽高和内外边距）&lt;/li&gt;
&lt;li&gt;内容间隙问题&lt;/li&gt;
&lt;li&gt;不同高度的对齐问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;初始HTML代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;  &amp;lt;main&amp;gt;
    &amp;lt;span&amp;gt;Hello&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;World&amp;lt;/span&amp;gt;
  &amp;lt;/main&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div id=&#34;html&#34;&gt;&lt;/p&gt;

&lt;p&gt;我们可以直接添加以下CSS内容来演示inline特性和block特性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;span {
  display: inline-block;
  width: 100px;
  height: 30px;

  border: 1px solid;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时呈现出来的效果为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/post/css-imgs/inline-block-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#top&#34;&gt;⬆返回顶部&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;内容间隙问题&#34;&gt;内容间隙问题&lt;/h2&gt;

&lt;p&gt;在上面的图中，可以很明显的看到两个span内容之间有一条缝隙，其实这是因为在换行显示或者空格分隔的情况下，就是显示出来一条缝隙。&lt;/p&gt;

&lt;p&gt;找到原因以后，我们就可以很方便的找到解决方法：
既然是有换行或者空格，那么直接删除不就好了。&lt;/p&gt;

&lt;p&gt;这时候开始修改HTML代码：&lt;/p&gt;

&lt;p&gt;&lt;main&gt;
    &lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;
  &lt;/main&gt;&lt;/p&gt;

&lt;p&gt;此时呈现出来的效果为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/post/css-imgs/inline-block-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这时候我们就可以看到效果，两个内容之间的缝隙已经被去除了。&lt;/p&gt;

&lt;p&gt;可是这时候又暴露出另一个问题，如果内容太多，连成一行就会影响代码的可读性，那么接下来我们看一下新的处理方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法：&lt;code&gt;font-size: 0&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在父元素上将字体大小设置为0，在分别设置子元素的字体大小。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是我们仍然使用初始HTML代码内容。&lt;/p&gt;

&lt;p&gt;修改后的CSS代码内容是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;main {
  font-size: 0;
}
span {
  display: inline-block;

  width: 100px;
  height: 30px;

  font-size: 18px;

  border: 1px solid;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;#top&#34;&gt;⬆返回顶部&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;不同高度的对齐问题&#34;&gt;不同高度的对齐问题&lt;/h2&gt;

&lt;p&gt;在目标内容高度不一致的情况下，互相对齐显得不是那么近和人意，因为使用
&lt;code&gt;display: inline-block&lt;/code&gt;后，内容变为行内块级元素，具有了行内元素的特性，内容将基于文字基线对齐，下面我们来验证一下。&lt;/p&gt;

&lt;p&gt;仍然使用初始化HTML代码内容，可以&lt;a href=&#34;#html&#34;&gt;点击查看内容&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;main {
  text-align: center;
  font-size: 0;
}
span {
  display: inline-block;

  font-size: 18px;

  border: 1px solid;
}

main :first-child {
  padding: 40px;
}

main :last-child {
  padding: 20px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候会这样显示（添加了参考线）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/post/css-imgs/inline-block-align-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果需要进行对齐，那么可以在父元素上面直接使用&lt;code&gt;vertical-align&lt;/code&gt;进行设置，比如给&lt;code&gt;span&lt;/code&gt;标签样式添加&lt;code&gt;vertical-align: bottom;&lt;/code&gt;那么将显示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/post/css-imgs/inline-block-align-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#top&#34;&gt;⬆返回顶部&lt;/a&gt;&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>使用Redux进行状态管理</title>
      <link>/post/javascript/redux-state-container-md/</link>
      <pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/javascript/redux-state-container-md/</guid>
      <description>
        

&lt;p&gt;&lt;div id=&#34;top&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;redux是什么&#34;&gt;Redux是什么&lt;/h2&gt;

&lt;p&gt;Redux是一个专注于状态管理的库：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redux专注于状态管理，和React并不是强结合的关系，使用Vue和Angular都可以结合Redux进行开发实践，也就是Redux和React解耦。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单一状态，也就是整个应用只会有一个综合状态，另外Redux是单向数据流。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;redux核心概念&#34;&gt;Redux核心概念&lt;/h2&gt;

&lt;h3 id=&#34;store&#34;&gt;store&lt;/h3&gt;

&lt;p&gt;保存数据的地方，整个应用的数据都保存在store中，每一个应用只能有一个store。&lt;/p&gt;

&lt;p&gt;store的创建方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { createStore } from &#39;redux&#39;;

const createStore(fn);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;createStore&lt;/code&gt;函数接受一个函数参数，用来生成store对象。&lt;/p&gt;

&lt;h3 id=&#34;state&#34;&gt;state&lt;/h3&gt;

&lt;p&gt;由于在tore中保存着应用的所有数据，因此需要获取某个时点的数据，就要对store生成快照。这种时点的数据集合，就叫做 State。&lt;/p&gt;

&lt;p&gt;state的获取方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { createStore } from &#39;redux&#39;;

const createStore(fn);

const state = store.getState();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;action&#34;&gt;action&lt;/h3&gt;

&lt;p&gt;在应用中，用户只能操作view层，如果需要改变状态数据，那么只能通过view发出通知去改变state，action就是view发出的通知。&lt;/p&gt;

&lt;p&gt;action是一个对象，必须具有type属性，用来表示action的名称。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const action = {
  type: &#39;ADD_GUN&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实际应用中，往往会有多种消息需要发送，此时我们可以定义一个函数来生成action，这个函数就称为action creator。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addGUN() {
  return {
    type: ADD_GUN,
  }
}

function removeGUN() {
  return {
    type: REMOVE_GUN,
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reducer&#34;&gt;Reducer&lt;/h3&gt;

&lt;p&gt;view发出通知，store收到action以后，必须更新state，view才会发生变化，这个state的计算过程就是Reducer。&lt;/p&gt;

&lt;p&gt;Reducer是一个函数，它接受当前state和action两个参数，然后返回一个新的state。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const ADD_GUN = &#39;add machine gun&#39;;
const REMOVE_GUN = &#39;remove machine gun&#39;;

// reducer
function counter(state = 0, action) {
  switch (action.type) {
    case ADD_GUN:
      return state + 1;
    case REMOVE_GUN:
      return state - 1;
    default:
      return 10;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;store-dispatch&#34;&gt;store.dispatch()&lt;/h3&gt;

&lt;p&gt;派发事件，传递action。&lt;/p&gt;

&lt;h3 id=&#34;store-subscribe&#34;&gt;store.subscribe()&lt;/h3&gt;

&lt;p&gt;设置监听，一旦state发生变化，就会自动执行这个函数。&lt;/p&gt;

&lt;p&gt;小例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { createStore } from &#39;redux&#39;;

const ADD_GUN = &#39;add machine gun&#39;;
const REMOVE_GUN = &#39;remove machine gun&#39;;

// Reducer
function counter(state = 0, action) {
  switch (action.type) {
    case ADD_GUN:
      return state + 1;
    case REMOVE_GUN:
      return state - 1;
    default:
      return 10;
  }
}

// action creator
function addGUN() {
  return {
    type: ADD_GUN,
  }
}

function removeGUN() {
  return {
    type: REMOVE_GUN,
  }
}

// create store
const store = createStore(counter);

// get init state
const init = store.getState();
console.log(init);

// set subscribe function
function listener() {
  const current = store.getState();
  console.log(`now,has gun ${current}`);
}
store.subscribe(listener);

// dispatch events
store.dispatch(addGUN());

store.dispatch(removeGUN());
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;redux中间件&#34;&gt;Redux中间件&lt;/h2&gt;

&lt;p&gt;Redux原生方法applyMiddlewares()用来使用中间件，作用是将所有中间件组成一个数组，并且依次执行，但是中间件的执行有次序要求，使用前需要查看相关文档。&lt;/p&gt;

&lt;h2 id=&#34;redux处理异步&#34;&gt;Redux处理异步&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用redux-thunk插件：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install redux-thunk
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;开启中间件并使用redux-thunk：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { createStore, applyMiddleware } from &#39;redux&#39;;
import thunk from &#39;redux-thunk&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改createStore为：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const store = createStore(counter, applyMiddleware(thunk));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建一个新的action：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addGunAsync() {
  return dispatch =&amp;gt; {
    setTimeout(() =&amp;gt; {
      dispatch(addGUN());
    }, 2000);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;派发新建的action：
&lt;code&gt;javascript
store.dispatch(addGunAsync());
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;chrome中的redux调试工具&#34;&gt;chrome中的Redux调试工具&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在chrome中安装扩展工具：Redux DevTools&lt;/li&gt;
&lt;li&gt;添加并修改createStore：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
const store = createStore(counter, /* preloadedState, */ composeEnhancers(
    applyMiddleware(thunk)
  ));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多使用方式可以到：&lt;a href=&#34;https://github.com/zalmoxisus/redux-devtools-extension&#34;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;

&lt;h2 id=&#34;使用react-redux&#34;&gt;使用react-redux&lt;/h2&gt;

&lt;p&gt;使用react-redux可以更加方便的管理应用状态，同时还可以忘记subscribe，使用Provider和connect两个接口来链接。&lt;/p&gt;

&lt;p&gt;具体使用方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Provider组件应用在最外层，传入store即可，只需要用一次；&lt;/li&gt;
&lt;li&gt;connect负责从外部获取组件需要的参数；&lt;/li&gt;
&lt;li&gt;connect可以用装饰器的方式来写。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用示例：
* 使用react-redux：&lt;a href=&#34;https://github.com/z2x/Feed-Up/commit/1cd34ce1fe6b5185912dbb578627c0c91def6a09&#34;&gt;点击查看&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用装饰器的方式写connect：&lt;a href=&#34;https://github.com/z2x/Feed-Up/commit/e6f011d916cf7978975c58b6c521926ef9d32092&#34;&gt;点击查看&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;#top&#34;&gt;⬆返回顶部&lt;/a&gt;&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Thu, 05 May 2016 21:48:51 -0700</pubDate>
      
      <guid>/about/</guid>
      <description>
        

&lt;h2 id=&#34;hello-world&#34;&gt;Hello world!&lt;/h2&gt;

&lt;p&gt;this is me.&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>Viridis Demo</title>
      <link>/1-example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/1-example/</guid>
      <description>
        


&lt;p&gt;The code below demonstrates two color palettes in the &lt;a href=&#34;https://github.com/sjmgarnier/viridis&#34;&gt;viridis&lt;/a&gt; package. Each plot displays a contour map of the Maunga Whau volcano in Auckland, New Zealand.&lt;/p&gt;
&lt;div id=&#34;viridis-colors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Viridis colors&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;image(volcano, col = viridis(200))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/1-example_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;magma-colors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Magma colors&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;image(volcano, col = viridis(200, option = &amp;quot;A&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/1-example_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
  </channel>
</rss>
